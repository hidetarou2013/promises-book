// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Traverser = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TokenSeeker = require("./TokenSeeker");

var _TokenSeeker2 = _interopRequireDefault(_TokenSeeker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var identity = function identity(arg) {
    return arg;
};

/*
 - Inline Block
 - Header, List ...
 - reset each line
 - Block
 - Source Code Block...
 - reset each end block
 */

var Blocker = function () {
    function Blocker(_ref) {
        var blockNodeNameList = _ref.blockNodeNameList;

        _classCallCheck(this, Blocker);

        this.blockNodeNameList = blockNodeNameList;
    }

    _createClass(Blocker, [{
        key: "beginNode",
        value: function beginNode(token) {
            var blockNodeNameList = this.blockNodeNameList;
            for (var i = 0; i < blockNodeNameList.length; i++) {
                var blockNode = blockNodeNameList[i];
                var begin = blockNode.begin;
                var targetScopes = token.scopes;
                if (targetScopes.indexOf(begin) !== -1) {
                    return blockNode;
                }
            }
        }
    }, {
        key: "getBeginType",
        value: function getBeginType(token) {
            var beginNode = this.beginNode(token);
            return beginNode ? beginNode.type : null;
        }
    }, {
        key: "getEndType",
        value: function getEndType(token) {
            var endNode = this.endNode(token);
            return endNode ? endNode.type : null;
        }
    }, {
        key: "endNode",
        value: function endNode(token) {
            var blockNodeNameList = this.blockNodeNameList;
            for (var i = 0; i < blockNodeNameList.length; i++) {
                var blockNode = blockNodeNameList[i];
                var end = blockNode.end;
                var targetScopes = token.scopes;
                if (targetScopes.indexOf(end) !== -1) {
                    return blockNode;
                }
            }
        }
    }, {
        key: "isBegin",
        value: function isBegin(token) {
            var beginNode = this.beginNode(token);
            return beginNode !== undefined;
        }
    }, {
        key: "isEnd",
        value: function isEnd(token) {
            var endNode = this.endNode(token);
            return endNode !== undefined;
        }
    }]);

    return Blocker;
}();

var InlineBlocker = function () {
    function InlineBlocker(_ref2) {
        var inlineBlockNodeNameList = _ref2.inlineBlockNodeNameList;

        _classCallCheck(this, InlineBlocker);

        this.inlineBlockNodeNameList = inlineBlockNodeNameList;
    }

    _createClass(InlineBlocker, [{
        key: "inlineNode",
        value: function inlineNode(node) {
            var matchNode = this.inlineBlockNodeNameList.filter(function (_ref3) {
                var begin = _ref3.begin;

                var scopes = node.scopes;
                return begin.every(function (scopeName) {
                    return scopes.indexOf(scopeName) !== -1;
                });
            });
            return matchNode.length !== 0 ? matchNode[0] : null;
        }
    }, {
        key: "getNodeType",
        value: function getNodeType(node) {
            var inlineNode = this.inlineNode(node);
            return inlineNode !== null ? inlineNode.type : null;
        }
    }, {
        key: "testInlineBlock",
        value: function testInlineBlock(node) {
            var inlineNode = this.inlineNode(node);
            return inlineNode !== null;
        }
    }]);

    return InlineBlocker;
}();

var blockNodeNameList = [{
    "type": "Header",
    "begin": "punctuation.definition.attributelistline.begin.asciidoc",
    "end": "punctuation.definition.attributelistline.end.asciidoc"
}, {
    /*
     ....
     Lorem ipsum.
     ....
      pre
     */
    "type": "CodeBlock",
    "begin": "constant.delimiter.block.literal.begin.asciidoc",
    "end": "constant.delimiter.block.literal.end.asciidoc"
}, {
    "type": "Comment",
    "begin": "punctuation.definition.comment.begin.asciidoc",
    "end": "punctuation.definition.comment.end.asciidoc"
}, {
    "type": "List",
    "begin": "constant.delimiter.listing.begin.asciidoc",
    "end": "constant.delimiter.listing.end.asciidoc"
}, {
    /*
     ****
     Lorem ipsum
     ****
     */
    "type": "Paragraph",
    "begin": "constant.delimiter.block.sidebar.begin.asciidoc",
    "end": "constant.delimiter.block.sidebar.end.asciidoc"
}, {
    "begin": "constant.delimiter.block.passthrough.begin.asciidoc",
    "end": "constant.delimiter.block.passthrough.end.asciidoc"
}, {
    "type": "BlockQuote",
    "begin": "constant.delimiter.block.quote.begin.asciidoc",
    "end": "constant.delimiter.block.quote.end.asciidoc"
}, {
    /*
     ====
     Lorem ipsum.
     ====
     */
    "type": "Paragraph",
    "begin": "constant.delimiter.example.begin.asciidoc",
    "end": "constant.delimiter.example.end.asciidoc"
}, {
    /*
     --
     Lorem ipsum
     --
     */
    "type": "CodeBlock",
    "begin": "constant.delimiter.block.open.begin.asciidoc",
    "end": "constant.delimiter.block.open.end.asciidoc"
}];
var getStrType = function getStrType(node) {
    return node.scopes.join(",") === ['text.asciidoc'].join(",") ? "Str" : null;
};
var inlineBlockNodeNameList = [
// #section_titles
{
    "type": "Header",
    "begin": ["punctuation.definition.heading.asciidoc"]
},
// #ulist_item_marker
{
    "begin": ["string.unquoted.list.bullet.asciidoc", "constant.numeric.list.bullet.asciidoc"]
},
// #comment
{
    "type": "Comment",
    "begin": ["punctuation.definition.comment.line.asciidoc", "meta.line.comment.content.asciidoc"]
},
// #block_title
{
    "type": "Paragraph",
    "begin": ["punctuation.definition.blockheading.asciidoc"]
}];

var Traverser = exports.Traverser = function () {
    function Traverser(tokens) {
        _classCallCheck(this, Traverser);

        this.seeker = Array.isArray(tokens) ? new _TokenSeeker2.default(tokens) : tokens;
    }

    _createClass(Traverser, [{
        key: "traverse",
        value: function traverse(_ref4) {
            var _ref4$enter = _ref4.enter;
            var enter = _ref4$enter === undefined ? identity : _ref4$enter;
            var _ref4$leave = _ref4.leave;
            var leave = _ref4$leave === undefined ? identity : _ref4$leave;

            var currentLineStack = [];
            var currentBlockStack = [];
            var blocker = new Blocker({ blockNodeNameList: blockNodeNameList });
            var inlineBlocker = new InlineBlocker({ inlineBlockNodeNameList: inlineBlockNodeNameList });
            var isInBlock = false;
            while (this.seeker.hasNextToken()) {
                var token = this.seeker.nextToken();
                token.type = blocker.getBeginType(token) || blocker.getEndType(token) || inlineBlocker.getNodeType(token) || getStrType(token);
                // Block Element
                if (blocker.isBegin(token)) {
                    isInBlock = true;
                    enter({
                        current: token,
                        type: blocker.getBeginType(token)
                    });
                    continue;
                } else if (blocker.isEnd(token)) {
                    isInBlock = false;
                    var parentToken = currentBlockStack[0];
                    while (currentBlockStack.length) {
                        var lastToken = currentBlockStack.pop();
                        leave({
                            current: lastToken,
                            parent: parentToken,
                            type: blocker.getEndType(token)
                        });
                    }
                    leave({
                        current: token,
                        type: blocker.getEndType(token)
                    });
                    continue;
                } else if (isInBlock) {
                    var _parentToken = currentBlockStack[0];
                    currentBlockStack.push(token);
                    enter({
                        current: token,
                        parent: _parentToken,
                        type: blocker.getBeginType(token)
                    });
                    continue;
                }
                // Inline Block
                if (inlineBlocker.testInlineBlock(token)) {
                    currentLineStack.push(token);
                    enter({
                        current: token,
                        type: blocker.getBeginType(token)
                    });
                    continue;
                } else if (currentLineStack.length > 0) {
                    var firstToken = currentLineStack[0];
                    if (firstToken.loc.start.line !== token.loc.start.line) {
                        while (currentLineStack.length) {
                            var _lastToken = currentLineStack.pop();
                            leave({
                                current: _lastToken,
                                parent: firstToken,
                                type: blocker.getEndType(_lastToken)
                            });
                        }
                    }
                    var _parentToken2 = currentLineStack[0];
                    currentLineStack.push(token);
                    enter({
                        current: token,
                        parent: _parentToken2
                    });

                    continue;
                } else {
                    var _parentToken3 = currentLineStack[0];
                    enter({
                        current: token,
                        parent: _parentToken3,
                        type: blocker.getBeginType(token)
                    });
                    continue;
                }
            }
            // finish
            while (currentLineStack.length > 0) {
                var _lastToken2 = currentLineStack.pop();
                leave({
                    current: _lastToken2,
                    type: blocker.getEndType(_lastToken2)
                });
            }
        }
    }]);

    return Traverser;
}();
//# sourceMappingURL=traverse.js.map