// LICENSE : MIT
"use strict";
/**
 * create paragraph node from TxtNodes.
 * @param {TxtNode[]} nodes - Child nodes
 * @return {TxtNode} Paragraph node
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function createParagraphNode(nodes) {
    return {
        type: "Paragraph",
        children: nodes || []
    };
}
function createBlockNode(token) {
    return {
        type: token.type,
        children: []
    };
}
/**
 * fill properties of paragraph node.
 * @param {TxtNode} node - Paragraph node to modify
 * @param {string} fullText - Full text of the document
 */
function fixParagraphNode(node, fullText) {
    var firstNode = node.children[0];
    var lastNode = node.children[node.children.length - 1];
    node.range = [firstNode.range[0], lastNode.range[1]];
    node.raw = fullText.slice(node.range[0], node.range[1]);
    node.loc = {
        start: {
            line: firstNode.loc.start.line,
            column: firstNode.loc.start.column
        },
        end: {
            line: lastNode.loc.end.line,
            column: lastNode.loc.end.column
        }
    };
}

var NodeBuilder = function () {
    function NodeBuilder(_ref) {
        var source = _ref.source;
        var text = _ref.text;

        _classCallCheck(this, NodeBuilder);

        var range = [0, text.length];
        this.AST = {
            type: "Document",
            raw: text,
            range: range,
            loc: source.rangeToLocation(range),
            children: []
        };
        this.text = text;
        this.source = source;
        this.currentParentNode = this.AST;
        this.currentStrStack = [];
    }

    _createClass(NodeBuilder, [{
        key: "builtAST",
        value: function builtAST() {
            var _this = this;

            this.wrapStrWithParagraph();
            this.AST.children.forEach(function (node) {
                if (node.type == "Paragraph") {
                    fixParagraphNode(node, _this.text);
                }
            });
            return this.AST;
        }
    }, {
        key: "addNodeToRoot",
        value: function addNodeToRoot(node) {
            this.AST.children.push(node);
        }
    }, {
        key: "backParentToRoot",
        value: function backParentToRoot() {
            this.currentParentNode = this.AST;
        }
    }, {
        key: "setCurrentParentNode",
        value: function setCurrentParentNode(token) {
            this.currentParentNode = createBlockNode(token);
            this.addNodeToRoot(this.currentParentNode);
        }
    }, {
        key: "isInBlock",
        value: function isInBlock() {
            return this.currentParentNode !== null;
        }
    }, {
        key: "pushStrToCurrentStack",
        value: function pushStrToCurrentStack(token) {
            // create range and raw
            token.raw = this.text.slice(token.startIndex, token.endIndex);
            token.value = token.raw;
            token.range = [token.startIndex, token.endIndex];
            delete token.startIndex;
            delete token.endIndex;
            this.currentStrStack.push(token);
        }
    }, {
        key: "wrapStrWithParagraph",
        value: function wrapStrWithParagraph() {
            if (this.currentStrStack.length === 0) {
                return;
            }
            var paragraph = createParagraphNode(this.currentStrStack);
            this.currentParentNode.children.push(paragraph);
            this.currentStrStack = [];
        }
    }, {
        key: "enterToken",
        value: function enterToken(token) {
            switch (token.type) {
                case "Str":
                    return this.pushStrToCurrentStack(token);
                // case "Paragraph":
                // case "Header":
                // case "List":
                //     return this.setCurrentParentNode(token);
                default:
                    this.wrapStrWithParagraph();
            }
        }
    }, {
        key: "exitToken",
        value: function exitToken(token) {
            // switch (token.type) {
            //     case "Paragraph":
            //     case "Header":
            //     case "List":
            //         this.wrapStrWithParagraph();
            //         return this.backParentToRoot();
            // }
        }
    }]);

    return NodeBuilder;
}();

exports.default = NodeBuilder;
module.exports = exports['default'];
//# sourceMappingURL=NodeBuilder.js.map