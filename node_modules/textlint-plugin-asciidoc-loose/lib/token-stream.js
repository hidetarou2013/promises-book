// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createTokenStream = createTokenStream;

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

var _vscodeTextmate = require("vscode-textmate");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var registry = new _vscodeTextmate.Registry();
var grammar = registry.loadGrammarFromPathSync(__dirname + '/../syntax/Asciidoctor.tmLanguage');
function createTokenStream(text) {
    var source = new _structuredSource2.default(text);
    var tokenList = [];
    var lines = text.split("\n");
    var ruleStack = null;
    var lineStartIndex = 0;
    lines.forEach(function (line) {
        // prev rule stack
        var parsed = grammar.tokenizeLine(line, ruleStack);
        for (var i = 0; i < parsed.tokens.length; i++) {
            var token = parsed.tokens[i];
            token.startIndex += lineStartIndex;
            token.endIndex += lineStartIndex;
            token.loc = {
                start: source.indexToPosition(token.startIndex),
                end: source.indexToPosition(token.endIndex)
            };
            tokenList.push(token);
        }
        ruleStack = parsed.ruleStack;
        lineStartIndex += line.length + 1;
    });
    return tokenList;
}
//# sourceMappingURL=token-stream.js.map