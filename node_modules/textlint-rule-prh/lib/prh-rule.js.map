{"version":3,"sources":["../src/prh-rule.js"],"names":[],"mappings":"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","file":"prh-rule.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {RuleHelper} from \"textlint-rule-helper\";\nimport StructuredSource from \"structured-source\";\nconst prh = require(\"prh\");\nconst path = require(\"path\");\nconst untildify = require('untildify');\nfunction createPrhEngine(rulePaths, baseDir) {\n    if (rulePaths.length === 0) {\n        return null;\n    }\n    const expandedRulePaths = rulePaths.map(rulePath => untildify(rulePath));\n    const prhEngine = prh.fromYAMLFilePath(path.resolve(baseDir, expandedRulePaths[0]));\n    expandedRulePaths.slice(1).forEach(ruleFilePath => {\n        const config = prh.fromYAMLFilePath(path.resolve(baseDir, ruleFilePath));\n        prhEngine.merge(config);\n    });\n    return prhEngine;\n}\nfunction createPrhEngineFromContents(yamlContents) {\n    if (yamlContents.length === 0) {\n        return null;\n    }\n    const prhEngine = prh.fromYAML(null, yamlContents[0]);\n    yamlContents.slice(1).forEach(content => {\n        const config = prh.fromYAML(null, content);\n        prhEngine.merge(config);\n    });\n    return prhEngine;\n}\nfunction mergePrh(...engines) {\n    const engines_ = engines.filter(engine => !!engine);\n    const mainEngine = engines_[0];\n    engines_.slice(1).forEach(engine => {\n        mainEngine.merge(engine);\n    });\n    return mainEngine;\n}\nconst assertOptions = (options) => {\n    if (typeof options.ruleContents === \"undefined\" && typeof options.rulePaths === \"undefined\") {\n        throw new Error(`textlint-rule-prh require Rule Options.\nPlease set .textlinrc:\n{\n    \"rules\": {\n        \"prh\": {\n            \"rulePaths\" :[\"path/to/prh.yml\"]\n        }\n    }\n}\n`);\n    }\n};\nfunction reporter(context, options = {}) {\n    assertOptions(options);\n    const textlintRcFilePath = context.config ? context.config.configFile : null;\n    // .textlinrc directory\n    const textlintRCDir = textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();\n    // create prh config\n    const rulePaths = options.rulePaths || [];\n    const ruleContents = options.ruleContents || [];\n    // yaml file + yaml contents\n    const prhEngineContent = createPrhEngineFromContents(ruleContents);\n    const prhEngineFiles = createPrhEngine(rulePaths, textlintRCDir);\n    const prhEngine = mergePrh(prhEngineFiles, prhEngineContent);\n    const helper = new RuleHelper(context);\n    const {Syntax, getSource, report, fixer, RuleError} = context;\n    return {\n        [Syntax.Str](node){\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            let text = getSource(node);\n            // to get position from index\n            let src = new StructuredSource(text);\n            let makeChangeSet = prhEngine.makeChangeSet(null, text);\n            makeChangeSet.diffs.forEach(function(changeSet) {\n                // | ----[match]------\n                var slicedText = text.slice(changeSet.index);\n                // | ----[match------|\n                var matchedText = slicedText.slice(0, changeSet.matches[0].length);\n                var expected = matchedText.replace(changeSet.pattern, changeSet.expected);\n                // Avoid accidental match(ignore case)\n                if (matchedText === expected) {\n                    return;\n                }\n                /*\n                 line start with 1\n                 column start with 0\n\n                 adjust position => line -1, column +0\n                 */\n                var position = src.indexToPosition(changeSet.index);\n\n                // line, column\n                report(node, new RuleError(matchedText + \" => \" + expected, {\n                    line: position.line - 1,\n                    column: position.column,\n                    fix: fixer.replaceTextRange([changeSet.index, changeSet.index + matchedText.length], expected)\n                }));\n            });\n        }\n    }\n}\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};"]}