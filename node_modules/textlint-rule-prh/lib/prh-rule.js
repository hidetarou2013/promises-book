// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var prh = require("prh");
var path = require("path");
var untildify = require('untildify');
function createPrhEngine(rulePaths, baseDir) {
    if (rulePaths.length === 0) {
        return null;
    }
    var expandedRulePaths = rulePaths.map(function (rulePath) {
        return untildify(rulePath);
    });
    var prhEngine = prh.fromYAMLFilePath(path.resolve(baseDir, expandedRulePaths[0]));
    expandedRulePaths.slice(1).forEach(function (ruleFilePath) {
        var config = prh.fromYAMLFilePath(path.resolve(baseDir, ruleFilePath));
        prhEngine.merge(config);
    });
    return prhEngine;
}
function createPrhEngineFromContents(yamlContents) {
    if (yamlContents.length === 0) {
        return null;
    }
    var prhEngine = prh.fromYAML(null, yamlContents[0]);
    yamlContents.slice(1).forEach(function (content) {
        var config = prh.fromYAML(null, content);
        prhEngine.merge(config);
    });
    return prhEngine;
}
function mergePrh() {
    for (var _len = arguments.length, engines = Array(_len), _key = 0; _key < _len; _key++) {
        engines[_key] = arguments[_key];
    }

    var engines_ = engines.filter(function (engine) {
        return !!engine;
    });
    var mainEngine = engines_[0];
    engines_.slice(1).forEach(function (engine) {
        mainEngine.merge(engine);
    });
    return mainEngine;
}
var assertOptions = function assertOptions(options) {
    if (typeof options.ruleContents === "undefined" && typeof options.rulePaths === "undefined") {
        throw new Error("textlint-rule-prh require Rule Options.\nPlease set .textlinrc:\n{\n    \"rules\": {\n        \"prh\": {\n            \"rulePaths\" :[\"path/to/prh.yml\"]\n        }\n    }\n}\n");
    }
};
function reporter(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    assertOptions(options);
    var textlintRcFilePath = context.config ? context.config.configFile : null;
    // .textlinrc directory
    var textlintRCDir = textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();
    // create prh config
    var rulePaths = options.rulePaths || [];
    var ruleContents = options.ruleContents || [];
    // yaml file + yaml contents
    var prhEngineContent = createPrhEngineFromContents(ruleContents);
    var prhEngineFiles = createPrhEngine(rulePaths, textlintRCDir);
    var prhEngine = mergePrh(prhEngineFiles, prhEngineContent);
    var helper = new _textlintRuleHelper.RuleHelper(context);
    var Syntax = context.Syntax;
    var getSource = context.getSource;
    var report = context.report;
    var fixer = context.fixer;
    var RuleError = context.RuleError;

    return _defineProperty({}, Syntax.Str, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var text = getSource(node);
        // to get position from index
        var src = new _structuredSource2.default(text);
        var makeChangeSet = prhEngine.makeChangeSet(null, text);
        makeChangeSet.diffs.forEach(function (changeSet) {
            // | ----[match]------
            var slicedText = text.slice(changeSet.index);
            // | ----[match------|
            var matchedText = slicedText.slice(0, changeSet.matches[0].length);
            var expected = matchedText.replace(changeSet.pattern, changeSet.expected);
            // Avoid accidental match(ignore case)
            if (matchedText === expected) {
                return;
            }
            /*
             line start with 1
             column start with 0
              adjust position => line -1, column +0
             */
            var position = src.indexToPosition(changeSet.index);

            // line, column
            report(node, new RuleError(matchedText + " => " + expected, {
                line: position.line - 1,
                column: position.column,
                fix: fixer.replaceTextRange([changeSet.index, changeSet.index + matchedText.length], expected)
            }));
        });
    });
}
module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=prh-rule.js.map